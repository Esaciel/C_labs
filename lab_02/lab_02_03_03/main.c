#include <stdio.h>
#include <math.h>
#define S 10


// Функция для разворота подаваемого ей целого числа 
int reverse(int num) 
{
    int original, digit, n = 0, result = 0, counter = 0;

    original = num;

    // Подсчет количества цифр в числе
    while (original != 0) 
    {
        original /= 10;
        n++;    
    }
    
    original = num;

    // Алгоритм математического разворота на основе общего количества цифр в нем
    while (original != 0)
    {
        counter++;
        digit = original % 10;
        original /= 10;
        result += digit * pow(10, n - counter);
    }

    // Возврат развернутого числа 
    return result;
}

// функция для вывода массива, принимает сам массив и длину обрабатываемой его части
void output_array(int*a, size_t len)
{
    for (size_t i = 0; i < len; i++)
    {
        printf("%d ", a[i]);
    }
}

// Функция заполнения нового массива, принимает начальный массив, новый массив и длину начального массива
int fill_new_array(int*a, int*new_a, size_t len)
{
    size_t new_len = 0;
    int rev_el;
    size_t j = 0;
    for (size_t i = 0; i < len; i++)
    {
        // Вводит в новый массив значение из старого,  увеличивает длину нового на единицу
        new_a[j] = a[i];
        new_len++;

        // Если данное число - положительное, на следующую позицию нового массива вводится развернутая версия этого числа, длина нового массива и переменная отслеживания его индекса увеличиваются на единицу
        if (a[i] > 0)
        {
            rev_el = reverse(a[i]);
            new_a[++j] = rev_el;
            new_len++;
        }
        // После завершения итерации переменная отслеживания индекса снова увеличивается на единицу 
        ++j;
    }

    // Вывод нового массива через функцию, выход с нулевым кодом возврата 
    printf("Массив с вставкой развернутого числа после каждого положительного элемента: ");
    output_array(new_a, new_len);
    return 0;
}

// Функция заполнение массива, принимает на вход сам массив и его обрабатываемую длину
int input_array(int*a, size_t len)
{
    for (size_t i = 0; i < len; i++)
    {
        // Записывает очередное значение в соответствующую ячейку памяти, в случае неудачной записи возвращает ненулевой код
        if (scanf("%d", &a[i]) != 1)
        {
            return 1;
        }
    }
    return 0;
}

int main(void) 
{
    int check = 0;
    size_t arr_len;

    // Ввод длины массива первым числом, в случае неверного ввода - сообщение об ошибке и ненулевой код возврата
    printf("Введите длину массива (от одного до десяти): ");
    check = scanf("%zu", &arr_len);
    if (check != 1 || arr_len < 1 || arr_len > 10)
    {
        printf("Введен неверный размер массива\n");
        return 1;
    }
    int array[S] = { 0 };
    int new_array[2 * S] = { 0 };

    int exit_code = 0;

    // Ввод начального массива через функцию, в случае неверного ввода - вывод сообщения об ошибке и выход с ненулевым кодом
    printf("Введите элементы целочисленного массива через пробел: ");
    exit_code = input_array(array, arr_len);
    if (exit_code != 0)
    {
        printf("Элементы введены неверно\n");
        return exit_code;
    }

    // Вывод начального массива
    // printf("Введенный массив: ");
    // output_array(array, arr_len);
    // printf("\n");

    // Заполнение нового массива и его вывод через соответствующую функцию, затем выход с идентичным этой функции кодом возврата
    exit_code = fill_new_array(array, new_array, arr_len);
    printf("\n");
    return exit_code;
}
